[toc]

# 项目整体框架



内碎片：

外碎片：





# ThreadCache

&emsp;thread cache是哈希桶的结构，每个桶实际上是一个按桶位置映射大小的内存块对象的自由链表。每个线程都会有一个自己的thread cache对象，这样每个线程在这里获取对象和释放对象时都是无锁的。





## 申请内存

### 向上对齐

&emsp;每个ThreadCache管理256KB的空间，为了更合理的管理，我们不能以1字节为单位进行对齐，这样的话一个ThreadCache就需要建立25w个自由链表了(**每个自由链表管理的对象大小都不同**)。因此我们采用更大字节数进行对齐，比如我们按照8字节来对齐，这样的话就需要建立256\*1024/8个自由链表了，实际上数目也有3w多，并且这种只按照8字节进行对齐的话，我们会发现划分空间时，内碎片的占比浮动很大。比如在字节数小的时候，假设我们索要2字节的空间，那么内碎片就占了(8-2)/8 = 75%；而当字节数大的时候，假设索要801字节的空间，那么内碎片占了(808-801)/808 = 0.8%左右。

---

这里先解释一下**向上对齐**，以便后续理解。

&emsp;当我们按照8字节来进行对齐时，会出现2种情况，一种是能够正好能整除8；另一种是不能整除8。当不能整除8时，我们就要进行向上对齐，就像结构体那样，需要浪费几个字节的空间。比如：当我们申请14字节时，实际上就是向第二个*(字节数从9-16映射到这个16字节的桶上)*自由链表去申请空间，申请1块大小位16字节的。再比如我们要申请129字节的空间，129属于[129, 1024]区间，因此采用16字节来对齐，而129不能整除16，因此要向上对齐，下一个能整除16的是144，因此他需要向*(字节数从129-144会映射到这个144字节的桶上)*自由链表申请空间，申请1块大小为144字节的。

---

&emsp;为了**均衡内碎片浪费的比例**以及**建立的自由链表的数目**(哈希桶的大小)，我们采用**不同的空间大小按照不同的字节数目来进行对齐**。

按照下面的范围划分以及不同范围字节数的对齐方式，能让整体控制在10%左右的**内碎片**浪费

|     申请的空间范围      |  对齐的字节数   |   自由链表的序号   |
| :---------------------: | :-------------: | :----------------: |
|         [1,128]         |    8字节对齐    |  freelist[0, 16)   |
|      [128+1, 1024]      |   16字节对齐    |  freelist[16, 72)  |
|    [1024+1, 8\*1024]    |   128字节对齐   | freelist[72, 128)  |
|  [8\*1024+1, 64\*1024]  |  1024字节对齐   | freelist[128, 184) |
| [64\*1024+1, 256\*1024] | 8\*1024字节对齐 | freelist[184, 208) |



**<font size="4">• 代码部分</font>**

&emsp;``RoundUp()``计算的是"**对齐到每块对象的大小为alignNum的自由链表上**"。比如14字节经计算后就会返回 从管理每块对象大小为16字节的自由链表上返回一块大小为16字节的对象。

这里解释一下``_RoundUp中的代码``。

举个例子，假设bytes是3字节，那么alignNum就是8字节。

32 16 8 4 2 1
      0 0 1 1      ``bytes``
      1 0 1 0      ``bytes + alignNum - 1``
\-------------------
        1 1 1	  ``alignNum - 1``
      1 0 0 0      ``~(aligNum - 1)``
\-------------------
      1 0 0 0      ``(bytes + alignNum - 1) & ~(alignNum - 1)``

**解释**：``~(alignNum - 1)``的目的是为了消除后面的零散位，同时保留最高位。而``bytes + alignNum``保证了它是向上对齐了，而``bytes + alignNum - 1``的-1则是让本身能够整除alignNum的数不会到下一个对齐数上。

```cpp
// 管理 空间范围划分与对齐、映射关系 的类
class SizeClass
{
public:
	static inline size_t _RoundUp(size_t bytes, size_t alignNum)	//align对齐数
	{
		//易于理解的写法
		//if (bytes % alignNum != 0)
		//{
		//	return (bytes + alignNum) / alignNum * alignNum;
		//}
		//else
		//{
		//	return bytes;
		//}

		//更优秀的写法
		return ((bytes + alignNum - 1) & ~(alignNum - 1));
	}

	static inline size_t RoundUp(size_t bytes)
	{
		if (bytes <= 128)
			return _RoundUp(bytes, 8);
		else if (bytes <= 1024)
			return _RoundUp(bytes, 16);
		else if (bytes <= 8 * 1024)
			return _RoundUp(bytes, 128);
		else if (bytes <= 64 * 1024)
			return _RoundUp(bytes, 1024);
		else if (bytes <= 256 * 1024)
			return _RoundUp(bytes, 8 * 1024);
		else
			assert(false);	//不在这个范围的，直接报错
        return 0;
	}
};
```

&emsp;

&emsp;

### 自由链表的下标









**• 代码部分**

```cpp
class SizeClass
{
public:
	//易于理解的写法
	//static inline size_t _Index(size_t bytes, size_t align_shift)
	//{
	//	if (bytes % (1 << align_shift) == 0)
	//	{
	//		return bytes / (1 << align_shift) - 1;
	//	}
	//	else
	//	{
	//		return bytes / (1 << align_shift);
	//	}
	//}

	//bytes是字节数，align_shift是该字节数所遵守的对齐数(以位运算中需要左移的位数表示)
	static inline size_t _Index(size_t bytes, size_t align_shift)
	{
		return ((bytes + (1 << align_shift) - 1) >> align_shift) - 1;
	}

	static inline size_t Index(size_t bytes)
	{
		assert(bytes <= MAX_BYTES);
		//每个对齐数的自由链表个数
		//static int group_freelist[4] = { 16, 56, 56, 56 };
         //用于扣除前面不属于当前对齐数的自由链表的个数
		static int group_freelist[4] = { 16, 72, 128, 184};
		if (bytes <= 128)
			return _Index(bytes, 3);	//3是2^3, 这里传的是 使用位运算要达到对齐数需要左移的位数
		else if (bytes <= 1024)
			return _Index(bytes - 128, 4) + group_freelist[0];
		else if (bytes <= 8 * 1024)
			return _Index(bytes - 8 * 1024, 7) + group_freelist[1];
		else if (bytes <= 64 * 1024)
			return _Index(bytes - 64 * 1024, 10) + group_freelist[2];
		else if (bytes <= 256 * 1024)
			return _Index(bytes - 256 * 1024, 13) + group_freelist[3];
		else
			assert(false);
		return -1;
	}
}
```



&emsp;

&emsp;

## 释放内存









&emsp;

&emsp;

## TLS无锁访问



















